"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsdLite = void 0;
const ts = require("@tsd/typescript");
const handleAssertions_1 = require("./handleAssertions");
const parser_1 = require("./parser");
const silenceError_1 = require("./silenceError");
const utils_1 = require("./utils");
function toTsdResult(rawResult) {
    return {
        messageText: rawResult.messageText,
        file: rawResult.file,
        start: rawResult.start,
    };
}
function tsdLite(testFilePath) {
    const compilerOptions = (0, utils_1.resolveCompilerOptions)(testFilePath);
    const program = ts.createProgram([testFilePath], compilerOptions || {});
    const syntacticDiagnostics = program.getSyntacticDiagnostics();
    if (syntacticDiagnostics.length !== 0) {
        throw new utils_1.TsdError(syntacticDiagnostics[0], "SyntaxError");
    }
    const semanticDiagnostics = program.getSemanticDiagnostics();
    const typeChecker = program.getTypeChecker();
    const { assertions, assertionsCount } = (0, parser_1.extractAssertions)(program);
    const assertionResults = (0, handleAssertions_1.handleAssertions)(typeChecker, assertions);
    const expectedErrors = (0, parser_1.parseErrorAssertionToLocation)(assertions);
    const expectedErrorsLocationsWithFoundDiagnostics = [];
    for (const diagnostic of semanticDiagnostics) {
        if ((0, utils_1.isDiagnosticWithLocation)(diagnostic)) {
            const silenceErrorResult = (0, silenceError_1.silenceError)(diagnostic, expectedErrors);
            if (silenceErrorResult !== "preserve") {
                if (silenceErrorResult !== "ignore") {
                    expectedErrorsLocationsWithFoundDiagnostics.push(silenceErrorResult);
                }
                continue;
            }
        }
        assertionResults.push(diagnostic);
    }
    for (const errorLocation of expectedErrorsLocationsWithFoundDiagnostics) {
        expectedErrors.delete(errorLocation);
    }
    for (const [, node] of expectedErrors) {
        assertionResults.push((0, handleAssertions_1.toAssertionResult)(node, "Expected an error, but found none."));
    }
    const tsdResults = assertionResults.map((result) => {
        return toTsdResult(result);
    });
    return { assertionsCount, tsdResults };
}
exports.tsdLite = tsdLite;

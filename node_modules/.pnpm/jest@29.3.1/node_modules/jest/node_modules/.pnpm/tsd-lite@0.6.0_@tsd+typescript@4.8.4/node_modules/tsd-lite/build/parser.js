"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseErrorAssertionToLocation = exports.extractAssertions = void 0;
const ts = require("@tsd/typescript");
const handleAssertions_1 = require("./handleAssertions");
const assertionFnNames = new Set(Object.values(handleAssertions_1.Assertion));
function extractAssertions(program) {
    const assertions = new Map();
    function visit(node) {
        var _a;
        if (ts.isCallExpression(node)) {
            const identifier = node.expression.getText();
            if (assertionFnNames.has(identifier)) {
                const assertion = identifier;
                const nodes = (_a = assertions.get(assertion)) !== null && _a !== void 0 ? _a : new Set();
                nodes.add(node);
                assertions.set(assertion, nodes);
            }
        }
        ts.forEachChild(node, visit);
    }
    for (const sourceFile of program.getSourceFiles()) {
        if (!sourceFile.isDeclarationFile) {
            visit(sourceFile);
        }
    }
    let assertionsCount = 0;
    assertions.forEach((nodes) => {
        assertionsCount += nodes.size;
    });
    return { assertions, assertionsCount };
}
exports.extractAssertions = extractAssertions;
function parseErrorAssertionToLocation(assertions) {
    const nodes = assertions.get(handleAssertions_1.Assertion.EXPECT_ERROR);
    const expectedErrors = new Map();
    if (!nodes) {
        return expectedErrors;
    }
    for (const node of nodes) {
        const location = {
            fileName: node.getSourceFile().fileName,
            span: ts.createTextSpanFromBounds(node.pos, node.end),
        };
        expectedErrors.set(location, node);
    }
    return expectedErrors;
}
exports.parseErrorAssertionToLocation = parseErrorAssertionToLocation;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectAssignable = exports.expectNotAssignable = void 0;
const _1 = require("./");
function expectNotAssignable(checker, nodes) {
    const tsdResults = [];
    if (!nodes) {
        return tsdResults;
    }
    for (const node of nodes) {
        if (!node.typeArguments) {
            continue;
        }
        const expectedType = checker.getTypeFromTypeNode(node.typeArguments[0]);
        const argumentType = checker.getTypeAtLocation(node.arguments[0]);
        if (checker.isTypeAssignableTo(argumentType, expectedType)) {
            tsdResults.push((0, _1.toAssertionResult)(node, `Argument of type '${checker.typeToString(argumentType)}' is assignable to parameter of type '${checker.typeToString(expectedType)}'.`));
        }
    }
    return tsdResults;
}
exports.expectNotAssignable = expectNotAssignable;
function expectAssignable(checker, nodes) {
    const tsdResults = [];
    if (!nodes) {
        return tsdResults;
    }
    for (const node of nodes) {
        if (!node.typeArguments) {
            continue;
        }
        const expectedType = checker.getTypeFromTypeNode(node.typeArguments[0]);
        const argumentType = checker.getTypeAtLocation(node.arguments[0]);
        if (!checker.isTypeAssignableTo(argumentType, expectedType)) {
            tsdResults.push((0, _1.toAssertionResult)(node, `Argument of type '${checker.typeToString(argumentType)}' is not assignable to parameter of type '${checker.typeToString(expectedType)}'.`));
        }
    }
    return tsdResults;
}
exports.expectAssignable = expectAssignable;
